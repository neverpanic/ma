% vim:noet:sts=2:ts=2:sw=2:smarttab:tw=120

\chapter{Extended Escape Analysis}
	\label{chapter:eea}
	A standard pattern found in C programs is passing a buffer and its size to a function which will write a computed
	result into the given buffer. Since the calling function controls the location of the buffer, it can be allocated from
	stack memory. In Java, a method would instead allocate a new object from heap and return a reference to it to achieve
	the same. Using alias information and escape analysis, objects that escape their method of alloction into the caller
	but no further can be automatically identified. Allocating these objects on the caller's stack and passing a reference
	avoids the need for garbage collection for these objects and can improve worst and average case execution times of
	programs. In the KESO context, this is called \emph{extended escape analysis} or \emph{(variable) scope extension}.

	\section{Algorithmic Idea}
		\label{sec:eea:idea}
		\inputthesiscode{java}{lst:eea:idea:builder}{Example containing a candidate for extended escape analysis}{%
			Example simplified from the CD\textsubscript{j} benchmark from the CD\textsubscript{x} family of
			benchmarks~\cite{kalibera:09:jtres}. The object allocated in \emph{Factory.getBuilder} does not escape
			\emph{Simulation.run}. It can be allocated on the stack of \emph{Simulation.run}.
		}{examples/Factory.java}
		\Cref{lst:eea:idea:builder} shows an example adapted from the source code of the CD\textsubscript{j}
		benchmark~\cite{kalibera:09:jtres} where the technique can be applied. The \emph{Builder} object allocated in
		\emph{Factory.getBuilder} escapes its allocating method into \emph{Simulation.run}, but is no longer referenced
		after line~\ref{line:eea:idea:builder:lastb}. It can be allocated in the stack frame of \emph{Simulation.run} and
		automatically reclaimed after \emph{Simulation.run} returns. A reference to the object would be passed to
		\emph{Factory.getBuilder} using a new, artificial parameter. The allocation operation in the callee would then be
		replaced with a parameter read. The invocation of the constructor of \emph{Builder} stays in
		\emph{Factory.getBuilder}.

		If the application can be interrupted between stack allocation in the caller and constructor call in the callee
		(e.g., by stop-the-world or on-demand garbage collection or a blocking method call) the referenced memory area must
		be in a defined state. Passing a reference to uninitialized memory (like in C) is not possible unless special
		precautions such as pointer tagging are used.

		Returning to the running example, the \emph{Builder} object can only be reclaimed by garbage collection without
		optimization. With optimization, the stack memory can be reused in later iterations of the loop for the same
		allocation, reducing the number of objects that need garbage collection at runtime.

		The examples discussed so far all deal with objects escaping their method of creation via a return operation. Note
		that being returned is not the only way for an object to escape: storing references in a field of an object given as
		parameter will also increase the escape state. This case is omitted in all examples for simplicity, but always
		implied.

	\section{Analysis}
		\label{sec:eea:analysis}
		Any object in the \emph{method} escape state partition of a method's \gls{cg} is a candidate for optimization. The
		escape state of the object's representation in the method's callers can be taken into account to decide whether the
		object should be allocated in the caller. Note that since there might be multiple callers and the optimization could
		be applied multiple times (moving allocations up multiple levels in the call hierarchy) considering the escape state
		of the object in the callers' \glspl{cg} is not always a trivial task. For example, the object might escape further
		in some of the callers but not in others. Virtual method invocations need to be handled with special care to avoid
		breaking the signature of these methods: all candidates for a virtual method invocation need to share the same
		signature before and after optimizing. See~\cref{sub:eea:analysis:virtual} for a detailed discussion of virtual
		method invocations in the context of extended escape analysis.

		KESO's implementation does not take the escape state of an object node's equivalents in the callers' \glspl{cg} into
		account. For each run of the analysis and optimization pass, allocations are propagated at most a single level up in
		the call hierarchy. Therefore, running the pass multiple times will increase the maximum scope extension level. Note
		that is is not necessarily beneficial to run the pass often, since it may lead to undesirable results (see
		below).\todo{add reference}

		\todonote{Give an overview of the algorithm JINO uses to extend the scope of a variable. Explain how and why it
		works and why we use stack allocation (and make sure to point out that stack allocation isn't the only possible
		optimization and may in fact be not the best). Quote my future work list on what other cool stuff could be done here
		and also outline which problems make this a hard problem.}

		\subsection{Nonvirtual Calls}
			\label{sub:eea:analysis:nonvirtual}
			Nonvirtual call sites, i.e., those where the invoked method is unique and known at compile time, constitute the
			simple cases of the analysis. The KESO compiler tries to increase the number of non-ambiguous invocations by
			devirtualizing method invocations where a single candidate can be deduced using static
			analysis~\cite[Sec.~3.4]{erhardt:11:jtres}.

			Each object node with a known allocation site (i.e., each non-phantom object node) and an escape state of
			\emph{method} will be optimized in KESO\@. Interference information for the allocated objects is not computed.
			This causes multiple allocations to be moved into calling methods even if they are allocated in mutually exclusive
			control flow paths. In some examples, this causes a large number of allocations and new method parameters even
			though only a few are used simultaneously. See~\cref{sec:conclusion:future-work} for possible ways to avoid this
			problem and a discussion of the challenges in solving it.

		\subsection{Virtual Calls}
			\label{sub:eea:analysis:virtual}
			Virtual method invocations further complicate the decision whether to move an allocation into calling methods or
			not. Because all candidates of a virtual method invocation must share the same signature (i.e., the same parameter
			and return types), a method cannot be optimized individually without considering other invocations possibly
			calling this method and these call site's possible callees.

			\begin{figure}
				\centering%
				\input{examples/vcall-eea.tex}%

				\caption[Call graph showing the complexity of extended escape allocation for virtual method calls]{%
					Call graph showing the complexity of extended escape allocation for virtual method calls.}%
				\label{fig:eea:analysis:virtual}%
			\end{figure}

			\todonote{Explain why virtual method calls are a much harder problem for scope extension and which possibilities
			can be employed to also apply the optimization in these cases (i.e., create a copy that has the optimization
			enabled, do not move the allocation but add explicit \texttt{free(3)}s, or employ some other method of automatic
			region inference).}

	\section{Optimization}
		\label{sec:eea:opt}

		\subsection{Extending Variable Scope}
			\label{sub:eea:opt:scopeext}

		\subsection{Local Domain Heaps}
			\label{sub:eea:opt:ldh}

	\todonote{What problems and undesirable results could occur due to excessive usage of the optimization?}
