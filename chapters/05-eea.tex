% vim:noet:sts=2:ts=2:sw=2:smarttab:tw=120

\chapter{Extended Escape Analysis}
	\label{chapter:eea}
	A standard pattern found in C programs is passing a buffer and its size to a function which will write a computed
	result into the given buffer. Since the calling function controls the location of the buffer, it can be allocated from
	stack memory. In Java, a method would instead allocate a new object from heap and return a reference to it to achieve
	the same. Using alias information and escape analysis, objects that escape their method of alloction into the caller
	but no further can be automatically identified. Allocating these objects on the caller's stack and passing a reference
	avoids the need for garbage collection for these objects and can improve worst and average case execution times of
	programs.

	\todonote{Explain what scope extension is, why we think it is a good idea and give a brief overview of how the
	information required can be computed from the results generated by escape analysis.}

	\section{Algorithmic Idea}
		\label{sec:eea:idea}
		\inputthesiscode{java}{lst:eea:idea:builder}{Example containing a candidate for extended escape analysis}{%
			Example simplified from the CD\textsubscript{j} benchmark from the CD\textsubscript{x} family of
			benchmarks~\cite{kalibera:09:jtres}. The object allocated in \emph{Factory.getBuilder} does not escape
			\emph{Simulation.run}. It can be allocated on the stack of \emph{Simulation.run}.
		}{examples/Factory.java}
		\todonote{Give an example of the pattern we are trying to achieve in C and compare with a Java implementation that
		returns a freshly allocated object. Observe that we need garbage collection to reclaim this object. Explain how we
		are trying to reduce the need for garbage collection by deducing which objects are no longer needed and can be
		freed.}

	\section{Analysis}
		\label{sec:eea:analysis}
		\todonote{Give an overview of the algorithm JINO uses to extend the scope of a variable. Explain how and why it
		works and why we use stack allocation (and make sure to point out that stack allocation isn't the only possible
		optimization and may in fact be not the best). Quote my future work list on what other cool stuff could be done here
		and also outline which problems make this a hard problem.}

		\subsection{Nonvirtual Calls}
			\label{sub:eea:analysis:nonvirtual}
			\todonote{Describe what we do for non-virtual calls (those are the easy ones!) and how the optimization applies.}

		\subsection{Virtual Calls}
			\label{sub:eea:analysis:virtual}
			\todonote{Explain why virtual method calls are a much harder problem for scope extension and which possibilities
			can be employed to also apply the optimization in these cases (i.e., create a copy that has the optimization
			enabled, do not move the allocation but add explicit \texttt{free(3)}s, or employ some other method of automatic
			region inference).}

	\section{Optimization}
		\label{sec:eea:opt}

		\subsection{Extending Variable Scope}
			\label{sub:eea:opt:scopeext}

		\subsection{Local Domain Heaps}
			\label{sub:eea:opt:ldh}
