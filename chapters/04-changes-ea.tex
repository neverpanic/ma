% vim:noet:sts=2:ts=2:sw=2:smarttab:tw=120

\chapter{Escape Analysis}
	\label{chapter:ea}
	KESO's compiler \emph{JINO} uses alias and escape analysis to identify objects whose lifetime is bounded by the
	runtime of their allocating method. The algorithm was implemented in~\cite{lang:12} and is largely based on the work
	of Choi et al.\ in 2003~\cite{choi:03:toplas}. The following section contains a brief description of the
	implementation and highlights differences. For an in-depth explanation, please refer to~\cite{lang:12}
	and~\cite{choi:03:toplas}. \Cref{sec:ea:improve} lists and explains the improvements written for this thesis.

	\section{Basics}
		\label{sec:ea:basics}
		The algorithm starts with alias analysis, which is separated into a method-local (also \emph{intraprocedural})
		analysis and a global (\emph{interprocedural}) analysis. To compute and store alias information, a specialized data
		structure called \gls{cg} is used. For each analyzed method, this graph contains representations of local variables,
		static class members, dynamic instance variables, array indices, and objects. Variables of non-reference type are
		ignored because they do not contribute to alias information.

		\subsection{Intraprocedural Analysis}
			\label{sub:ea:basics:local}
			In intraprocedural analysis, each method in the call graph of an application is traversed and a \gls{cg}
			representation is being computed. It is a key contribution of Choi et al.\ that this representation is independent
			of the calling context. Since the origin of objects might not be known for some objects (e.g.\ if the have been
			passed as argument), a special type of placeholder called \emph{phantom node} is used to represent these objects.
			For pointer analysis as discussed in~\cref{sec:intro:prev} summarizing independent of the aliasing relationships
			in the calling context is impossible~\cite[p.~886]{choi:03:toplas}. For each allocation, assignment, field or
			array access, return statement, method invocation, and exception throw, the \gls{cg} is modified appropriately,
			ensuring possible alias relations are represented accurately.

			Nodes in the \gls{cg} have different types: \emph{Object nodes} are added for each encountered allocation site.
			Note that a single object node in the graph might represent multiple objects at runtime because an allocation
			might be executed multiple times (e.g.\ if it is inside a loop). Local variables, static class members, and member
			variables are represented using \emph{local reference nodes}, \emph{global reference nodes}, and \emph{field
			reference nodes} respectively. Array indices are treated like fields and are thus also represented by a field
			reference node. Each reference node can point to a series of object nodes and also to other reference nodes using
			\emph{deferred edges}. Deferred edges are used to simplify updates of the \gls{cg} while processing assignments.
			After intraprocedural analysis, these edges are removed by replacing all incoming deferred edges of a reference
			node with edges to its successors. Different from the work of Choi et al.\ reference nodes with incoming deferred
			but no outgoing edges are preserved without change. \Cref{subsec:ea:improve:bug} gives the rationale
			underlying this difference. Finally, object nodes can point to field reference nodes, denoting that the pointed
			field exists inside the object where the edge originates.

			Each node in the \gls{cg} has one of three \emph{escape states}, indicating whether a node will outlive its
			allocating method, or even thread. Among these states, a total order exists. \emph{Local} is the lowest state.
			Nodes marked local do not escape the analyzed method. Next after local is \emph{method}. Nodes that outlive
			a method by being returned or assigned to an object passed as parameter are tagged method-escaping. The highest
			escape state is \emph{global} and is given to objects and references that are assigned to static class members or
			thrown as exception. While processing a method's instructions and building the \gls{cg}, operations that cause the
			escape state of one of their parameters to change trigger the appropriate change in the escape states recorded in
			the connection graph. Allocations whose object node representation in the \gls{cg} is tagged local are considered
			for stack allocation.

			\inputthesiscode{java}{lst:ea:basics:ll}{A simple generic linked list in Java}{%
				A simple generic linked list implementation in Java. Note that this example is more complex than it would have
				to be, especially due to the \emph{insert} method, for demonstration purposes.\\[.5em] An inner class is used to
				wrap the list entries with references to their successor. The \emph{addElement} method allows insertion of new
				entries. Internally, \emph{addElement} uses \emph{insert}, which enqueues the given new element at the start of
				a list.
			}{examples/LinkedList.java}

			See~\cref{lst:ea:basics:ll} for source code corresponding to the \glspl{cg} to be explained in depth. The code
			example is a simple generic linked list. Using common sense we can deduce that, in the absence of a removal
			operation, all list elements will be reachable until the list itself has reached the end of its lifetime.
			Consequently, the only allocation in the given example can not be allocated on the stack, because it must outlive
			the method of its allocation \emph{addElement}. Due to the structure of the example, intraprocedural analysis will
			not suffice to determine this. Global analysis will be necessary.

			\begin{figure}
				\centering%
				\subcaptionbox{%
					\Acrlong{cg} for \emph{addElement}. \emph{insert(list)} and \emph{insert(elem)} represent the parameters
					passed to the \emph{insert} method at its invocation. \emph{$\langle$init$\rangle$(this)} and
					\emph{$\langle$init$\rangle$(elem)} do the same for the implicit invocation of \emph{ListElement}'s
					constructor.%
					\label{subfig:ea:basics:ll:addElement}}[.5\textwidth]{%
						\centering%
						\input{examples/LinkedList-addElement-intra.tex}%
				}%
				\hspace{\fill}%
				\subcaptionbox{%
					\Acrlong{cg} for \emph{insert}. The edge from \emph{head} to \emph{obj1} is the one that prevents stack
					allocation of the list element in \emph{addElement}. Interprocedural analysis needs to propagate this edge
					into the caller context to determine this.\label{subfig:ea:basics:ll:insert}}[.48\textwidth]{%
						\centering%
						\input{examples/LinkedList-insert-intra.tex}%
				}%
				\caption[The \glsentryshortpl{cg} for \emph{addElement} and \emph{insert} after intraprocedural analysis]{%
					The \acrlongpl{cg} for the \emph{addElement} and \emph{insert} methods given in~\cref{lst:ea:basics:ll} after
					intraprocedural analysis. Vertices with rounded corners represent \emph{reference nodes}, where \emph{field
					reference nodes} have a red {\color{cgred}\blacksquare}, other reference nodes a blue
					{\color{cgblue}\blacksquare} border. Dotted borders mark artificial reference nodes representing a method's
					parameter or return value. Rectangles with green {\color{cggreen}\blacksquare} borders are \emph{object
					nodes}. If the border is dashed, the node is a \emph{phantom node}. The escape state of nodes is encoded in
					the fill color. White, orange {\color{cgorange}\blacksquare}, and red {\color{cgwarn}\blacksquare} represent
					\emph{local}, \emph{method}, and \emph{global} respectively.}%
				\label{fig:ea:basics:ll}%
			\end{figure}

			See~\cref{fig:ea:basics:ll} for the \acrlongpl{cg} of the methods \emph{insert} and \emph{addElement} given
			in~\cref{lst:ea:basics:ll}. The \emph{addElement} method has two parameters, but only the second one is visible in
			the code listing. Java implicitly passes the \emph{this} reference as first argument. These parameters are
			represented in \cref{subfig:ea:basics:ll:addElement} by two reference nodes with dotted borders. Since they are
			reachable after the method returns, they are marked as \emph{method}-escaping, denoted by the orange fill color.
			Because the allocation sites of the pointees of both \emph{this} and \emph{elem} are unknown, these objects are
			represented using \emph{phantom nodes} (dashed green rectangle). Note that the escape state propagates along the
			edges from \emph{this} into \emph{obj0} and from \emph{elem} into its pointee \emph{obj1}. The first statement in
			the bytecode representation of \emph{addElement} is the allocation of a new list element, which causes the
			creation of an object node (green rectangle) in the \gls{cg}. The constructor of the newly created
			\emph{ListElement} is called with two arguments: a reference to the object and a reference to the given parameter
			\emph{elem}, represented in the \acrlong{cg} by the \emph{$\langle$init$\rangle$(this)} and
			\emph{$\langle$init$\rangle$(elem)} reference nodes. The \emph{this} parameter of the constructor invocation
			points to the allocated list element, denoted by a solid edge in the graph. The algorithm can deduce that
			\emph{$\langle$init$\rangle$(elem)} points to the same object as \emph{elem}, but the pointees of \emph{elem} are
			unknown at this point. Adding a deferred edge encodes this situation. Finally, processing the invocation of
			\emph{insert} creates a similar set of nodes \emph{insert(list)} and \emph{insert(elem)} pointing to the
			\emph{this} reference and the \emph{ListElement} object respectively.

			The graph for \emph{insert} is given in~\cref{subfig:ea:basics:ll:insert}. The two parameters are again
			represented by a reference node and a phantom node each. The first few statements create the \emph{next} field
			node below \emph{obj1} and add a deferred edge to \emph{head}. This edge is not shown in the graph, because the
			next statement in the code changes the value of \emph{head}. Depending on whether the analysis is flow-sensitive
			or not, the outcome will differ. The \gls{cg} given uses the flow-sensitive variant, which causes all incoming
			deferred edges of a reference node to be compressed and all outgoing edges to be removed before pointing to the
			new target. Because compression of deferred edges requires at least one edge outgoing from the target of the
			deferred edge, but \emph{head} did not have any at this point in the analysis, a phantom node representing the
			previous pointees of \emph{head} was created. It is denoted \emph{oldhead} in~\cref{subfig:ea:basics:ll:insert}.
			Using flow-insensitive analysis, the deferred edge from \emph{next} to \emph{head} would have been preserved and
			later compressed into an edge from \emph{next} to \emph{obj1}. Finally, the edge from \emph{head} to \emph{obj1}
			is added to represent the effect of the statement in line~\ref{line:ea:basics:ll:headassign}
			in~\cref{lst:ea:basics:ll}, completing intraprocedural analysis.

		\subsection{Interprocedural Analysis}
			\label{sub:ea:basics:global}
			Looking at the summary information generated for both methods given in~\cref{lst:ea:basics:ll}, the object node
			that represents the only allocation (\emph{LinkedList} in~\cref{subfig:ea:basics:ll:addElement}) has an escape
			state of \emph{local} at this point in the analysis. Recall that local nodes are considered for stack allocation,
			but entries of a linked list cannot be allocated on stack. The results are thus not sound and further analysis is
			required. Looking at the example, the edge from \emph{head} to \emph{obj1} in the \gls{cg} of \emph{insert} is the
			edge that will prevent stack allocation of the list element in \emph{addElement}. To determine this
			algorithmically, the edges found while processing \emph{insert} need to be propagated to its caller
			\emph{addElement}. Once the connection from \emph{obj0} via a new field reference node \emph{head} to the list
			element is established, the escape state of the \emph{ListElement} object node increase to \emph{method}, making
			the result sound.

			A second analysis pass propagates information from the non-\emph{local} subgraph of the \glspl{cg} into the
			\glspl{cg} of all calling methods. This \emph{interprocedural} analysis modifies the summary information of the
			callers, which in turn require their callers to be updated again. To prevent unnecessary recalculation of
			information, this pass should use a bottom-up traversal of the call graph. In the absence of recursion, the call
			graph will not contain cycles, making this a simple problem. When recursion is used, identifying strongly
			connected components and iterating in each component until a fixpoint is reached has proved to be effective.
			KESO's implementation uses Tarjan's algorithm to identify strongly connected components in the call
			graph~\cite{tarjan:72:lga}.

			To update the callers' \acrlongpl{cg}, pairs of corresponding nodes in the graph on the caller and the callee side
			are identified as starting points and added to a work list. Originating at these anchors, further nodes and their
			counterparts are found and again added to the work list. While the work list isn't empty, processing continues and
			builds a relation of object nodes in the callee and the caller \gls{cg} called \emph{mapsToObj}. This step is
			called \emph{updateNodes}. A simplified form of the procedure is given in~\cref{algo:ea:basics:updateNodes}. It
			uses a dual work list approach to avoid creating spurious phantom nodes because some of the relationships might
			not be known until the algorithm completes. See~\cite[Sec.~3.2.1]{lang:12} for a detailed explanation of the
			problem that causes unneeded phantom nodes to be added and slows down the analysis. \emph{UpdateNodes} ensures
			that all object nodes used in a callee are represented in its caller. It also adds field reference nodes present
			in the callee \gls{cg} but missing from the caller's graph and marks the counterparts of globally escaping nodes
			in the callee's \gls{cg} as globally escaping in the caller \gls{cg}.

			\begin{algorithm}
				\SetKwData{workList}{workList}
				\SetKwData{needsPointee}{needsPointee}
				\SetKwData{mapsToObj}{mapsToObj}
				\SetKwData{mParam}{mParam}
				\SetKwData{iArg}{iArg}
				\SetKwData{x}{x}
				\SetKwData{y}{y}
				\SetKwData{xs}{xs}
				\SetKwData{ys}{ys}
				\SetKwData{xd}{xd}
				\SetKwData{yd}{yd}
				\SetKwData{xPointees}{xPointees}
				\SetKwData{yPointees}{yPointees}
				\SetKwData{calleeField}{calleeField}
				\SetKwData{callerField}{callerField}
				\SetKwData{callerObjs}{callerObjs}
				\SetKwFunction{updateNodes}{updateNodes}
				\SetKwFunction{updateEscapeState}{updateEscapeState}
				\SetKwFunction{pop}{pop}
				\SetKwFunction{pointees}{pointees}
				\SetKwFunction{fields}{fields}
				\SetKwFunction{getField}{getField}
				\SetKwFunction{addEdges}{addEdges}
				\SetKwFunction{createPhantom}{createPhantom}
				\SetKw{continue}{continue}

				\SetKwInOut{Input}{Input}
				\SetKwInOut{Output}{Result}
				\Input{\xs: method parameters, \ys: invocation arguments}
				\Output{\mapsToObj relation between caller and callee nodes}
				\BlankLine
				\DontPrintSemicolon
				\updateNodes$\left( \xs, \ys \right)$\;
				\PrintSemicolon
				\Begin{%
					\workList $= \left\{ (\x, \y) \left|\; \x \leftarrow \xs \left|\; \y \leftarrow \ys \right.\right.\right\}$\;
					\needsPointee $= \emptyset$\;
					\mapsToObj $= \emptyset$\;
					\While{$\workList \ne \emptyset \;\mathrm{or}\; \needsPointee \ne \emptyset$}{%
						\While{$\workList \ne \emptyset$}{%
							$\left(\mParam, \iArg\right) = \pop{\workList}$\;
							\BlankLine
							\tcp{Mark \mParam globally escaping if \iArg is.}
							$\updateEscapeState{\mParam, \iArg}$\;
							\BlankLine
							\tcp{Find pairs of descendant object nodes}
							$\xPointees = \pointees{\mParam}$\;
							$\yPointees = \pointees{\iArg}$\;
							\eIf{$\xPointees \equiv \emptyset \;\mathrm{or}\; \yPointees \ne \emptyset$}{%
								\tcp{Find pairs of field reference nodes}
								\ForEach{$\left( \xd, \yd \right) \in \left\{ (\x, \y) \left|\; \x \leftarrow \xPointees,\; \y \leftarrow \yPointees \right.\right\}$}{%
									$\mapsToObj{\xd} \;\cup\!\!= \yd$\;
									\ForEach{$\calleeField \in \fields{\xd}$}{%
										$\callerField = \getField{\yd, \calleeField}$\;
										$\workList \;\cup\!\!= (\calleeField, \callerField)$\;
									}
								}
							}{%
								\tcp{The callee node is not represented in the caller node}
								$\needsPointee \;\cup\!\!= (\mParam, \iArg)$\;
							}
						}
						\While{$\workList \equiv \emptyset \;\mathrm{and}\; \needsPointee \ne \emptyset$}{%
							\ForEach{$(\mParam, \iArg) \in \needsPointee$}{%
								\eIf{$\pointees{\iArg} \ne \emptyset$}{%
									\tcp{\mParam's pointees are represented (happens with recursion)}
								}{%
									\tcp{Check for other representatives of pointees of \mParam}
									$\callerObjs = \left\{ \x \left|\; \x \leftarrow \mapsToObj{\y} \left|\; \y \leftarrow \pointees{\mParam} \right.\right.\right\}$\;
									\eIf{$\callerObjs \ne \emptyset$}{%
										\addEdges{\iArg, \callerObjs}\;
									}{%
										\tcp{Delay adding phantom nodes}
										\continue\;
									}
								}
								$\needsPointee \;\setminus\!\!= (\mParam, \iArg)$\;
								$\workList \;\cup\!\!= (\mParam, \iArg)$\;
							}
							\If{$\workList \equiv \emptyset$}{%
								\tcp{\workList is still empty, no pairs found. Add a phantom node.}
								$(\mParam, \iArg) = \pop{\needsPointee}$\;
								$\addEdges{\iArg, \createPhantom{\mParam}}$\;
								$\workList \;\cup\!\!= (\mParam, \iArg)$\;
							}
						}
					}
				}

				\caption[The \emph{updateNodes} procedure]{The \emph{updateNodes} procedure~\cite[Alg. 2]{lang:12}}
				\label{algo:ea:basics:updateNodes}
			\end{algorithm}

			For the example given in~\cref{lst:ea:basics:ll} and~\cref{subfig:ea:basics:ll:addElement}, this means that the
			field reference nodes \emph{head} and \emph{next} are added below \emph{obj0} and \emph{ListElement} respectively.
			Furthermore, a phantom node is added to represent \emph{oldhead}. Note that the \emph{head} reference node does
			not yet point to the list element object node. The next step of the algorithm called \emph{updateEdges} adds the
			missing connection. It takes the same parameters as \emph{updateNodes} from~\cref{algo:ea:basics:updateNodes} and
			adds all missing edges. See~\cref{algo:ea:basics:updateEdges} for a pseudocode listing of the procedure. It
			identifies pairs of corresponding object nodes using the \emph{mapsToObj} relation computed in \emph{updateNodes}.
			For each possible pair it follows outgoing edges to any field reference nodes in the callee graph and finds the
			corresponding field reference node in the caller's \gls{cg}. Next, the newly found correspondence pair is added to
			the work list and all outgoing edges to object nodes in the callee graph are added to the caller graph. Note that
			code to prevent endless loops in cylic data structures has been left out for simplicity, but can be easily added.

			\begin{algorithm}
				\SetKwData{workList}{workList}
				\SetKwData{mParam}{mParam}
				\SetKwData{pairs}{pairs}
				\SetKwData{x}{x}
				\SetKwData{y}{y}
				\SetKwData{xs}{xs}
				\SetKwData{ys}{ys}
				\SetKwData{i}{i}
				\SetKwData{j}{j}
				\SetKwData{k}{k}
				\SetKwData{mapsToObj}{mapsToObj}
				\SetKwData{field}{field}
				\SetKwFunction{fields}{fields}
				\SetKwFunction{updateEdges}{updateEdges}
				\SetKwFunction{pop}{pop}
				\SetKwFunction{pointees}{pointees}
				\SetKwFunction{getField}{getField}
				\SetKwFunction{addEdges}{addEdges}

				\SetKwInOut{Input}{Input}
				\SetKwInOut{Output}{Result}
				\Input{\xs: method parameters, \ys: invocation arguments}
				\BlankLine
				\DontPrintSemicolon
				\updateEdges$\left( \xs, \ys \right)$\;
				\PrintSemicolon
				\Begin{%
					$\workList = \xs$\;
					\While{$\workList \ne \emptyset$}{%
						$\mParam = \pop{\workList}$\;
						\ForEach{$(\x, \y) \in \left\{ (\x, \y) \left|\; \y \leftarrow \mapsToObj{\x} \left|\; \x \leftarrow \pointees{\mParam} \right.\right.\right\}$}{%
							\ForEach{$(\i, \j) \in \left\{ (\field, \getField{\y, \field}) \left|\; \field \leftarrow \fields{\x} \right.\right\}$}{%
								$\workList \;\cup\!\!= (\i, \j)$\;
								\addEdges{$\j, \left\{ \mapsToObj{\k} \left|\; \k \leftarrow \pointees{\i} \right.\right\}$}\;
							}
						}
					}
				}

				\caption[The \emph{updateEdges} procedure]{The \emph{updateEdges} procedure~\cite[Alg. 3]{lang:12}}
				\label{algo:ea:basics:updateEdges}
			\end{algorithm}

			After interprocedural analysis, nodes marked \emph{local} in the \gls{cg} can be allocated on the stack. Note that
			KESO does not convert all allocations that fulfill this criterion into stack allocations. Instead, variable
			liveness information is used to compute whether multiple objects allocated at the same allocation site are needed
			at the same time. Objects with overlapping liveness regions are not allocated on the stack because the amount of
			memory used by these allocations might be unbounded, e.g.\ if the allocation is inside a loop.
			See~\cite[Sec.~3.3]{lang:12} for detailed rationale and a description of the implementation.

	\section{Improvements}
		\label{sec:ea:improve}
		The algorithm implemented in~\cite{lang:12}, which is based on~\cite{choi:03:toplas}, was improved for this thesis
		in a number of ways. Among these improvements was flow-sensitivity, which was proposed by Choi et al.\ in 2003, but
		not implemented in my bachelor's thesis. The changes required to achieve flow-sensitivity are outlined in the
		following~\cref{subsec:ea:improve:fs}. Furthermore, a problem producing possibly incorrect
		results was discovered in the algorithm given in~\cite{choi:03:toplas}. \Cref{subsec:ea:improve:bug} gives an
		example and explains where the incorrect analysis results occur and how they were fixed in KESO's implementation.

		Last but not least, the algorithm's runtime on large examples amounted to several minutes and was deemed
		unsatisfactory. Especially recursive and virtual method invocations significantly increased the size of the
		generated \glspl{cg}, raising the runtime of interprocedural analysis. \Cref{subsec:ea:improve:opt} deals with
		modifications implemented to reduce the runtime of the alias analysis.

		\subsection{Flow-Sensitivity}
			\label{subsec:ea:improve:fs}
			For flow-sensitive alias analysis a standard forward data flow analysis~\cite[Sec.~9.2]{aho:07:compilers} is used.
			The set of operations needed for data flow analysis is
			\begin{align}
				C_o^b &= f_b\left( C_i^b \right)\label{eq:ea:improve:fs:transfer}\\
				C_i^b &= \bigwedge_{x \;\in\; \operatorname{pred}(b)} C_o^x\label{eq:ea:improve:fs:meet}
			\end{align}
			where $C_i^b$ and $C_o^b$ are input and output data flow information for the basic block $b$, $f_b$
			in~\cref{eq:ea:improve:fs:transfer} is called the \emph{transfer function} for the basic block $b$, and $\wedge_{x
			\;\in\; \operatorname{pred}(b)}$ in~\cref{eq:ea:improve:fs:meet} is the \emph{meet} operation. The data flow
			transfer function modifies the data flow information (i.e., the \acrlong{cg}) according to the statements in the
			basic block $b$. The meet operation combines the output information of all predecessors of a basic block into the
			input information of a given basic block $b$. The basics of the transfer function are explained in~\cite{lang:12,
			choi:03:toplas}. In theory, all $C^b$ are distinct. In practice, this would manifold the memory requirements for
			the \glspl{cg}. Instead of copying the graph in each invocation of the transfer and meet operations, KESO's
			implementation uses a single representation. This idea is also present in~\cite[Sec.~3]{choi:03:toplas}, but is
			not explained very well. In specific, it is not clear to the author of this thesis what Choi et al.\ meant when
			they wrote \enquote{in the flow-sensitive version, we only kill local variables}~\cite[p.~885]{choi:03:toplas}.

			The KESO compiler achieves flow-sensitivity while retaining a single representation of the \gls{cg} by tagging all
			reference nodes with the basic block for which they are valid. Object nodes are not modified for flow-sensitive
			analysis. For each reference node used in at least one predecessor, the meet operation creates a representation of
			the reference in the current basic block and subsumes all outgoing edges present in the predecessors. For each
			assignment operation encountered by the transfer function, \emph{ByPass(p)} is called on the reference to be
			written. \emph{ByPass(p)} (as explained in~\cite{choi:03:toplas}) redirects all incoming deferred edges of $p$ to
			its successors and removes any outgoing edges (i.e., it ensures that strong updates are performed).

			After implementing this improvement, a fixpoint iteration used to reduce the number of unnecessary phantom nodes
			in intraprocedural analysis did no longer terminate for some inputs. This happened because the iteration tracked
			changes to the \gls{cg} rather than comparing the graph against an older copy. Due to the use of \emph{ByPass(p)},
			the graph was modified in every loop, but further processing returned to the previous state again. Switching to
			a comparison against an old copy of the \gls{cg} rather than tracking of modifications fixed this particular
			problem. To efficiently implement comparisons against older versions of the same graph, the \acrlong{cg}'s nodes
			were extended with the ability to store a copy of a single older state of outgoing edges.

		\subsection{Fixing Incorrect Results: The Double Return Bug}
			\label{subsec:ea:improve:bug}
			KESO's implementation of escape analysis produced incorrect results given inputs similar to those generated by the
			idea outlined in~\cref{sec:eea:idea}. Further analysis suggests this is a conceptual flaw in the work of Choi et
			al. See~\cref{lst:ea:improve:bug} for an example triggering this bug. The \emph{getObject} method allocates two
			objects and passes them to \emph{chooseOne}, which selects one of them at random and returns it. The return value
			of \emph{chooseOne} is then returned from \emph{getObject}. Because either of the two objects allocated in
			\emph{getObject} might escape, both allocations must not use stack memory.

			\inputthesiscode{java}{lst:ea:improve:bug}{Example exposing the double return flaw}{%
				A simplified example exposing the double return bug in KESO's escape analysis. One of the objects allocated in
				\emph{getObject} is returned from its allocating method, but escape analysis did not detect this due to the use
				of phantom nodes to represent return values.
			}{examples/ChooseOne.java}

			However, the \gls{cg} constructed according to~\cite[Sec.~4]{choi:03:toplas} does not correctly identify the two
			objects as method-escaping. The \acrlong{cg} for \emph{chooseOne} is straightforward and given
			in~\cref{subfig:ea:improve:bug:chooseOne}. For the \gls{cg} of \emph{getObject}, Sections~4.3 \enquote{The
			Connection Graph Immediately Before a Method Invocation} and 4.4 \enquote{The Connection Graph Immediately After
			a Method Invocation} are the relevant parts of~\cite{choi:03:toplas}. According to the first section a new
			\emph{actual reference node} is created for each argument of the invocation and an assignment $\hat{a_i} = u_i$ is
			processed. $\hat{a_i}$ denotes the actual reference nodes, $u_i$ are the corresponding invocation arguments. The
			statement causes the creation of deferred edges from the $\hat{a_i}$'s to the $u_i$'s, which will later be
			compressed.

			\begin{figure}
				\centering%
				\subcaptionbox{%
					The \gls{cg} for \emph{chooseOne}.%
					\label{subfig:ea:improve:bug:chooseOne}}[.35\textwidth]{%
						\centering%
						\input{examples/ChooseOne-chooseOne.tex}%
				}%
				\hspace{\fill}%
				\subcaptionbox{%
					The \gls{cg} for \emph{getObject} according to~\cite[Sec.~4]{choi:03:toplas}.%
					\label{subfig:ea:improve:bug:getObject}}[.62\textwidth]{%
						\centering%
						\input{examples/ChooseOne-getObject.tex}%
				}%
				\caption[The \glspl{cg} for \emph{getObject} and \emph{chooseOne} exhibiting the double return flaw]{%
					The \glspl{cg} for \emph{getObject} and \emph{chooseOne} from~\cref{lst:ea:improve:bug}, exhibiting the
					double return flaw. The object nodes in \emph{getObject} should be pointed-to by \emph{ret}, which would
					raise their escape state to \emph{method}, but these edges are missing. Colors and shapes
					c.f.~\cref{fig:ea:basics:ll}.}%
				\label{fig:ea:improve:bug}%
			\end{figure}

			The handling of return values is not explicitly explained in this section, but the next section mentions them as
			\enquote{$\hat{a_i}$'s (representing actual arguments and return value) of the caller's CG,}
			\cite[p.~891]{choi:03:toplas} suggesting that an \emph{actual reference node} for the return value is added in the
			caller's \gls{cg}. \Cref{subfig:ea:improve:bug:getObject} shows this \acrlong{cg}: The rounded rectangles with
			blue dotted borders are said \emph{actual reference nodes}. Both \emph{chooseOne(a)} and \emph{chooseOne(b)}
			initially have a single outgoing edge pointing to a local variable, which in turn points to the allocated objects.
			This indirection is omitted from the graph in~\cref{subfig:ea:improve:bug:getObject} for simplicity. The return
			value of \emph{getObject} is modelled using assignments to a special \enquote{phantom} variable called
			\emph{return} (in KESO's implementation: \emph{ret}). Since the result of the call to \emph{chooseOne} is returned
			from \emph{getObject}, a deferred edge from the phantom return variable to the \emph{actual reference node}
			representing \emph{chooseOne}'s return value is added. After completing intraprocedural escape analysis all
			deferred edges are removed from the graph according to Choi et al., adding phantom nodes where necessary. This
			leads to the creation of the phantom node denoted \emph{objret} in \cref{subfig:ea:improve:bug:getObject}. The
			following path compression removes the deferred edges from \emph{ret} to \emph{chooseOne(ret)} and adds
			a \emph{points-to} edge to \emph{ret}. The \emph{method} escape state of \emph{chooseOne(ret)} is retained, but is
			not relevant for the further problem description.

			\begin{table}
				\centering
				\subcaptionbox{%
					The \emph{mapsToObj} relation constructed using \emph{updateNodes} as given in~\cite{choi:03:toplas}. Note
					that this is the same even after KESO's modifications.%
					\label{subtbl:ea:improve:bug:mto}}[.54\linewidth]{%
						\centering%
						\begin{tabular}{rl}
							\textbf{chooseOne} & \textbf{getObject} \\\hline\hline
							obj0 & Object\textsuperscript{(a)}, objret\\
							obj1 & Object\textsuperscript{(b)}, objret\\ \\
						\end{tabular}%
				}%
				\hspace{\fill}%
				\subcaptionbox{%
					The \emph{mapsToRef} relation constructed using KESO's modified \emph{updateNodes} algorithm.%
					\label{subtbl:ea:improve:bug:mtr}}[.44\linewidth]{%
						\centering%
						\begin{tabular}{rl}
							\textbf{chooseOne} & \textbf{getObject} \\\hline\hline
							a   & chooseOne(a)\\
							b   & chooseOne(b)\\
							ret & chooseOne(ret)
						\end{tabular}%
				}%
				\caption[%
					The \emph{mapsToObj} and \emph{mapsToRef} relations for the call of \emph{chooseOne} from \emph{getObject}]{%
					The \emph{mapsToObj} and \emph{mapsToRef} relations for the call of \emph{chooseOne} from \emph{getObject} as
					given in~\cref{lst:ea:improve:bug}.}
				\label{tbl:ea:improve:bug:mapsTo}
			\end{table}

			The analysis ends with the \emph{UpdateCaller} routine. It consists of \emph{UpdateNodes} and \emph{UpdateEdges}.
			The former computes equivalence pairs of object nodes in the callee's and caller's \glspl{cg} (the so-called
			\emph{mapsToObj} relation) and adds phantom nodes for objects that have no equivalence in the caller yet.
			\emph{UpdateEdges} ensures all relevant edges present in the callee's \gls{cg} are propagates into the caller's
			graph. The \emph{mapsToObj} relation for the call from \emph{getObject} to \emph{chooseOne} is given
			in~\cref{subtbl:ea:improve:bug:mto}. If \emph{chooseOne(ret)} did not yet have any pointees at this point of the
			analysis, statement 7 in \emph{UpdateNodes} as displayed in~\cite[Fig.~7]{choi:03:toplas} would have created it as
			a phantom node, leading to the same problem. No new edges are inserted in interprocedural analysis for this
			example, because no structure of the form $p \rightarrow f_p \rightarrow q$ (where $p, q$ are object nodes and
			$f_p$ is a field reference node) exists in the \gls{cg} of \emph{chooseOne}.

			Note that both phantom nodes in \emph{chooseOne}'s \gls{cg} map to both their respective object node and the
			\emph{objret} phantom node, but the equivalence of \emph{Object\textsuperscript{(x) $\forall x \in \{a,b\}$}} and
			\emph{objret} is not represented in \emph{getObject}'s \gls{cg}, leading to incorrect escape states for the two
			allocated objects.

			To work around this problem, KESO's alias analysis (outlined in~\cref{algo:ea:basics:updateNodes,%
			algo:ea:basics:updateEdges}) was extended to not only track equivalences between object nodes in \emph{mapsToObj},
			but also between reference nodes in a new relation called \emph{mapsToRef}. This data is used in a modified
			version of \emph{updateEdges} to add the missing edges in the caller's \gls{cg}. On each occasion of
				$p \rightarrow o$
			in the callee's \gls{cg} where $p$ is a reference node that does not represent a parameter and $o$ is an object
			node, an edge
				$x \rightarrow y$
			is added in the caller's \gls{cg} for each
				$x \in \text{\emph{mapsToRef}}(p)$ and $y \in \text{\emph{mapsToObj}}(o)$,
			if no such edge exists yet. Edges outgoing from parameters must be ignored in this step because Java has
			call-by-value semantics which means that the arguments given at a method invocation will always remain unchanged.
			All references reachable via other edges below the arguments can be modified, however, as can the return value.

			Using this extension for the running example generates the \emph{mapsToRef} relation as given
			in~\cref{subtbl:ea:improve:bug:mtr}. To avoid the superfluous phantom node \emph{objret} that would be added
			because of the removal of deferred edges before interprocedural analysis, KESO's alias analysis does not attach
			phantom nodes to nodes that have incoming deferred but not outgoing edges. This required modifying the analysis to
			be able to deal with deferred edges in interprocedural analysis. After the modified interprocedural analysis
			finishes, the \gls{cg} of \emph{getObject} (depicted in~\cref{fig:ea:improve:bug:fix}) contains the missing edges.

			\begin{figure}
				\centering%
				\input{examples/ChooseOne-getObject-fixed.tex}%

				\caption[The \gls{cg} for \emph{getObject} with the double return flaw fixed]{%
					The \gls{cg} for \emph{getObject} as generated by KESO's modified algorithm to fix the double return flaw. The
					two object nodes are correctly marked \emph{method}-escaping. Colors and shapes c.f.~\cref{fig:ea:basics:ll}.}%
				\label{fig:ea:improve:bug:fix}%
			\end{figure}

		\subsection{Interprocedural Analysis Optimizations}
			\label{subsec:ea:improve:opt}
			Some of the larger applications (up to $23.8~k\mathrm{SLOC}$\footnote{generated using David A.\ Wheeler's
			\enquote{SLOCCount}}) used in testing the KESO compiler took up to 19 minutes to compile with alias and escape
			analysis enabled. The compile times were dominated by the duration of alias analysis. To reduce this unacceptable
			overhead, a series of possible culprits were identified and modifications to the algorithm to optimize compile
			times were implemented. Since the vast majority of the time was spent in interprocedural analysis, all
			optimizations described in the following sections apply to this part of alias analysis.

			\subsubsection{No Propagation of Read Operations}
				\label{subsub:ea:improve:opt:writeonly}
				Analyzing the generated \glspl{cg} after interprocedural analysis revealed virtual invocations of methods that
				in turn call the same set of virtual methods caused the size of the graphs to increase rapidly. This situation
				commonly occurs in Java with simultaneous use of the \emph{equals} method and collections (whose \emph{equals}
				implementations call \emph{equals} once for each element in the collection). Since calling \emph{equals} usually
				does not change any references reachable from its parameters it does not add new aliases. Based on this
				observation, the intraprocedural analysis was extended to track all edges that were added to the \gls{cg} due to
				a write operation. KESO's implementation uses a set of properties called \emph{isWritten} and
				\emph{isWriteOperand} available in each \acrlong{cg} node to store this, because information cannot be easily
				attached to the edges themselves in KESO's adjacency list-based implementation of the \gls{cg}. After
				intraprocedural analysis, a modified version of Tarjan's algorithm to find strongly connected
				components~\cite{tarjan:72:lga} finds all cycle-free paths from the method's formal parameters to edges created
				by write operations. All edges that compose this subgraph are called \emph{important} and marked for later use.
				Note that the subgraph may contain cycles because while \emph{important} edges alone will not cause cycles, an
				additional edge created by a write operation might. Furthermore, intraprocedural analysis was extended to ignore
				all nodes and edges that have no role in a write operation and are not marked \emph{important} (i.e., are not on
				a path from the method's entry points to a write operation edge).

				In theory, these changes should have removed the effect of calls to \emph{equals}, \emph{hashCode} and similar
				methods completely. In practice, however, some implementations of \emph{equals} may in fact contain write
				operations: For example, the \emph{java.util.Hashtable} class from the GNU classpath project implements
				\emph{equals} by comparing the entry sets of the two hash tables. This entry set is eagerly created and cached
				inside the hash table class. This write operation causes all edges leading up to it to be marked important.
				These edges are then propagated into all other invocations of \emph{equals}, causing further edges to be
				considered important, nullifying the effect of the optimization for \emph{equals}. Other implementations and
				functions might however still benefit from the improvement. If Java did have constant methods like \C++{} does,
				\emph{equals} (and other methods that are marked constant and only have constant reference parameters) could be
				automatically ignored in alias analysis.

			\subsubsection{No Reprocessing of Unchanged Invocations}
				\label{subsub:ea:improve:opt:quick-fixpoint}
				Strongly connected components in an application's call graph (i.e., recursive methods) are handled in
				interprocedural analysis by iterating until a fixpoint has been reached. During this process, invocations might
				be reprocessed even though their callees' \glspl{cg} did not change since the last iteration. This happens for
				all call graph edges leaving the strongly connected component. See~\cref{fig:ea:improve:quick-fixpoint} for
				a graphical representation of this situation.

				\begin{figure}
					\centering%
					\input{examples/invocation-reprocessing.tex}%

					\caption[Example call graph where avoiding reprocessing saves time]{%
						Call graph with a strongly connected component (blue {\color{cgblue}\blacksquare} vertices) and a few
						dependent nodes (green {\color{cggreen}\blacksquare} vertices). While methods inside the strongly connected
						component might have to be visited multiple times in interprocedural analysis, the summary information from
						\texttt{a}–\texttt{c} only needs to be propagated into their callers once.}%
					\label{fig:ea:improve:quick-fixpoint}%
				\end{figure}

				KESO's implementation of interprocedural analysis only re-runs the \emph{updateNodes} and \emph{updateEdges}
				steps if a callee's \gls{cg} changed since the last iteration, avoiding unnecessary overhead. Unfortunately the
				savings from this optimizations are marginal.

			\subsubsection{Connection Graph Compression}
				\label{subsub:ea:improve:opt:compression}
				While the improvements in~\cref{subsub:ea:improve:opt:writeonly,subsub:ea:improve:opt:quick-fixpoint} reduced
				the compile time of large applications, the savings were still not enough to enable escape analysis by default
				in KESO without having a noticeable effect during development. \Acrlong{cg} sizes would still surpass 10000
				vertices on large inputs with these optimizations enabled, slowing down further steps of the analysis. Most of
				these nodes were created in interprocedural analysis as phantom nodes to represent objects allocated in callees
				of the current function and often had siblings that would represent the same objects. To reduce the size of the
				\acrlongpl{cg}, a graph compression transformation inspired by Steensgaard's almost linear time points-to
				analysis~\cite{steensgaard:96:popl} was implemented.

				Starting at each entry point into a method's \gls{cg} (i.e., every method parameter and the return value), the
				graph compression algorithm processes each reference node recursively but avoids loops using a color bit. For
				each reference node, lists of pointees segregated by escape state are collected. The separation into different
				escape states ensures that object nodes are only unified with nodes that have the same escape state. This avoids
				deterioration of the computed results up to this point. Each list that contains at least two object nodes and at
				least one phantom node is compressed by removing the phantom nodes. Note that any two non-phantom object nodes
				(i.e., any two nodes with a known allocation site) are not consolidated to preserve the one-to-one mapping
				between intermediate code allocation instruction and its \gls{cg} representation.

				Incoming edges pointing to the phantom nodes to be removed are redirected to the retained object nodes. Field
				reference nodes reachable from the phantom nodes are re-created below the object nodes in the compression set.
				Edges outgoing from the removed field reference nodes are moved to their equivalents below the retained object
				nodes. Since this might create new graph constellations that can be compressed, the color bit possibly marking
				the descendant field reference nodes as visited is reset.

				Since these modifications always preserve object nodes and do not unify subgraphs with different escape states,
				the effect on the results is negligible. However, the compile time required for alias analysis has improved by
				an order of magnitude.

	\section{Applications}
		\label{sec:ea:apps}
		Besides stack allocation, the results of KESO's escape analysis can be used for other applications. This section
		presents some of the analyses and optimizations that use the \acrlongpl{cg} generated by alias and escape analysis.
		Note that some of the ideas outlined have proved to be difficult or impossible to implement using KESO's
		representation of the alias information, and some are possible but have not been implemented yet due to time
		constraints.

		\subsection{Removing Unneeded Copies in Portal Calls}
			\label{sub:ea:apps:spca}
			To support communication between protection realms (\emph{domains}), KESO offers an \gls{rpc} implementation
			called \emph{portals} (see also~\cref{fig:intro:overview}). To ensure complete isolation of objects passed through
			portals, the KESO runtime environment creates deep copies of the objects in the target domain's heap. This ensures
			that modifications of the object in the target domain do not affect the object in the source domain. Especially
			for large trees of objects, this is very expensive. Results from escape and alias analysis can be used to
			determine whether the copy can be omitted.

			Objects must be copied, if they, or any object reachable from one of their fields, \begin{inparaenum}[(a)]
				\item live longer than the runtime of the methods handling the portal call on the destination side, i.e., if
					they have a global escape state in the callee's \gls{cg}, or \label{item:sub:ea:apps:spca:escape}
				\item are modified by the caller. \label{item:sub:ea:apps:spca:write}
			\end{inparaenum}

		\subsection{Synchronization Optimizations}
			\label{sub:ea:apps:sync}

		\subsection{Cycle-Aware Reference Counting}
			\label{sub:ea:apps:cycledescriptors}
