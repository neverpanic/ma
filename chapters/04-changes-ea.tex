% vim:noet:sts=2:ts=2:sw=2:smarttab:tw=120

\chapter{Escape Analysis}
	\label{chapter:ea}
	KESO's compiler \emph{JINO} uses alias and escape analysis to identify objects whose lifetime is bounded by the
	runtime of their allocating method. The algorithm was implemented in~\cite{lang:12} and is largely based on the work
	of Choi et al.\ in 2003~\cite{choi:03:toplas}. The following section contains a brief description of the
	implementation and highlights differences. For an in-depth explanation, please refer to~\cite{lang:12}
	and~\cite{choi:03:toplas}. \Cref{sec:ea:improve} lists and explains the improvements written for this thesis.

	\section{Basics}
		\label{sec:ea:basics}
		The algorithm starts with alias analysis, which is separated into a method-local (also \emph{intraprocedural})
		analysis and a global (\emph{interprocedural}) analysis. To compute and store alias information, a specialized data
		structure called \gls{cg} is used. For each analyzed method, this graph contains representations of local variables,
		static class members, dynamic instance variables, array indices, and objects. Variables of non-reference type are
		ignored because they do not contribute to alias information.

		\subsection{Intraprocedural Analysis}
			\label{sub:ea:basics:local}
			In intraprocedural analysis, each method in the call graph of an application is traversed and a \gls{cg}
			representation is being computed. It is a key contribution of Choi et al.\ that this representation is independent
			of the calling context. Since the origin of objects might not be known for some objects (e.g.\ if the have been
			passed as argument), a special type of placeholder called \emph{phantom node} is used to represent these objects.
			For pointer analysis as discussed in~\cref{sec:intro:prev} summarizing independent of the aliasing relationships
			in the calling context is impossible~\cite[p.~886]{choi:03:toplas}. For each allocation, assignment, field or
			array access, return statement, method invocation, and exception throw, the \gls{cg} is modified appropriately,
			ensuring possible alias relations are represented accurately.

			Nodes in the \gls{cg} have different types: \emph{Object nodes} are added for each encountered allocation site.
			Note that a single object node in the graph might represent multiple objects at runtime because an allocation
			might be executed multiple times (e.g.\ if it is inside a loop). Local variables, static class members, and member
			variables are represented using \emph{local reference nodes}, \emph{global reference nodes}, and \emph{field
			reference nodes} respectively. Array indices are treated like fields and are thus also represented by a field
			reference node. Each reference node can point to a series of object nodes and also to other reference nodes using
			\emph{deferred edges}. Deferred edges are used to simplify updates of the \gls{cg} while processing assignments.
			After intraprocedural analysis, these edges are removed by replacing all incoming deferred edges of a reference
			node with edges to its successors. Different from the work of Choi et al.\ reference nodes with incoming deferred
			but no outgoing edges are preserved without change. \Cref{subsec:ea:improve:bug} gives the rationale
			underlying this difference. Finally, object nodes can point to field reference nodes, denoting that the pointed
			field exists inside the object where the edge originates.

			Each node in the \gls{cg} has one of three \emph{escape states}, indicating whether a node will outlive its
			allocating method, or even thread. Among these states, a total order exists. \emph{Local} is the lowest state.
			Nodes marked local do not escape the analyzed method. Next after local is \emph{method}. Nodes that outlive
			a method by being returned or assigned to an object passed as parameter are tagged method-escaping. The highest
			escape state is \emph{global} and is given to objects and references that are assigned to static class members or
			thrown as exception. While processing a method's instructions and building the \gls{cg}, operations that cause the
			escape state of one of their parameters to change trigger the appropriate change in the escape states recorded in
			the connection graph. Allocations whose object node representation in the \gls{cg} is tagged local are considered
			for stack allocation.

			See~\cref{lst:ea:basics:ll} for source code corresponding to the \glspl{cg} to be explained in depth. The
			code example is a simple generic linked list. Using common sense we can deduce that, in the absence of a removal
			operation, all list elements will be reachable until the list itself has reached the end of its lifetime.
			Consequently, the only allocation in the given example can not be allocated on the stack, because it must outlive
			the method of its allocation \texttt{addElement}. Due to the structure of the example, intraprocedural analysis
			will not suffice to determine this. Global analysis will be necessary.

			\inputthesiscode{java}{lst:ea:basics:ll}{A simple generic linked list in Java}{%
				A simple generic linked list implementation in Java. Note that this example is more complex than it would have to
				be, especially due to the \texttt{insert} method, for demonstration purposes.\\[.5em]
				An inner class is used to wrap the list entries with references to their successor. The \texttt{addElement} method
				allows insertion of new entries. Internally, \texttt{addElement} uses \texttt{insert}, which enqueues the given
				new element at the start of a list.
			}{examples/LinkedList.java}

			\begin{figure}
				\centering%
				\subcaptionbox{%
					\Acrlong{cg} for \texttt{addElement}. \texttt{insert(list)} and \texttt{insert(elem)} represent the parameters
					passed to the \texttt{insert} method at its invocation. \texttt{<init>(this)} and \texttt{<init>(elem)} do the
					same for the implicit invocation of \texttt{ListElement}'s constructor.%
					\label{subfig:ea:basics:ll:addElement}}[.5\textwidth]{%
						\centering%
						\input{examples/LinkedList-addElement-intra.tex}%
				}%
				\hspace{\fill}%
				\subcaptionbox{%
					\Acrlong{cg} for \texttt{insert}. The edge from \texttt{head} to \texttt{obj1} is the one that prevents stack
					allocation of the list element in \texttt{addElement}. Interprocedural analysis needs to propagate this edge
					into the caller context to determine this.\label{subfig:ea:basics:ll:insert}}[.48\textwidth]{%
						\centering%
						\input{examples/LinkedList-insert-intra.tex}%
				}%
				\caption[The \glsentryshortpl{cg} for \texttt{addElement} and \texttt{insert} after intraprocedural analysis]{%
					The \acrlongpl{cg} for the \texttt{addElement} and \texttt{insert} methods given in~\cref{lst:ea:basics:ll}
					after intraprocedural analysis. Vertices with rounded corners represent \emph{reference nodes}, where
					\emph{field reference nodes} have a red {\color{cgred}\blacksquare}, other reference nodes a blue
					{\color{cgblue}\blacksquare} border. Dotted borders mark artificial reference nodes representing a method's
					parameter or return value. Rectangles with green {\color{cggreen}\blacksquare} borders are \emph{object
					nodes}. If the border is dashed, the node is a \emph{phantom node}. The escape state of nodes is encoded in
					the fill color. White, orange {\color{cgorange}\blacksquare}, and red {\color{cgwarn}\blacksquare} represent
					\emph{local}, \emph{method}, and \emph{global} respectively.}%
				\label{fig:ea:basics:ll}%
			\end{figure}

			See~\cref{fig:ea:basics:ll} for the \acrlongpl{cg} of the methods \texttt{insert} and \texttt{addElement} given
			in~\cref{lst:ea:basics:ll}. The \texttt{addElement} method has two parameters, but only the second one is visible
			in the code listing. Java implicitly passes the \texttt{this} reference as first argument. These parameters are
			represented in \cref{subfig:ea:basics:ll:addElement} by two reference nodes with dotted borders. Since they are
			reachable after the method returns, they are marked as \emph{method}-escaping, denoted by the orange fill color.
			Because the allocation sites of the pointees of both \texttt{this} and \texttt{elem} are unknown, these objects
			are represented using \emph{phantom nodes} (dashed green rectangle). Note that the escape state propagates along
			the edges from \texttt{this} into \texttt{obj0} and from \texttt{elem} into its pointee \texttt{obj1}. The first
			statement in the bytecode representation of \texttt{addElement} is the allocation of a new list element, which
			causes the creation of an object node (green rectangle) in the \gls{cg}. The constructor of the newly created
			\texttt{ListElement} is called with two arguments: a reference to the object and a reference to the given
			parameter \texttt{elem}, represented in the \acrlong{cg} by the \texttt{<init>(this)} and \texttt{<init>(elem)}
			reference nodes. The \texttt{this} parameter of the constructor invocation points to the allocated list element,
			denoted by a solid edge in the graph. The algorithm can deduce that \texttt{<init>(elem)} points to the same
			object as \texttt{elem}, but the pointees of \texttt{elem} are unknown at this point. Adding a deferred edge
			encodes this situation. Finally, processing the invocation of \texttt{insert} creates a similar set of nodes
			\texttt{insert(list)} and \texttt{insert(elem)} pointing to the \texttt{this} reference and the
			\texttt{ListElement} object respectively.

			The graph for \texttt{insert} is given in~\cref{subfig:ea:basics:ll:insert}. The two parameters are again
			represented by a reference node and a phantom node each. The first few statements create the \texttt{next} field
			node below \texttt{obj1} and add a deferred edge to \texttt{head}. This edge is not shown in the graph, because
			the next statement in the code changes the value of \texttt{head}. Depending on whether the analysis is
			flow-sensitive or not, the outcome will differ. The \gls{cg} given uses the flow-sensitive variant, which causes
			all incoming deferred edges of a reference node to be compressed and all outgoing edges to be removed before
			pointing to the new target. Because compression of deferred edges requires at least one edge outgoing from the
			target of the deferred edge, but \texttt{head} did not have any at this point in the analysis, a phantom node
			representing the previous pointees of \texttt{head} was created. It is denoted \texttt{oldhead}
			in~\cref{subfig:ea:basics:ll:insert}. Using flow-insensitive analysis, the deferred edge from \texttt{next} to
			\texttt{head} would have been preserved and later compressed into an edge from \texttt{next} to \texttt{obj1}.
			Finally, the edge from \texttt{head} to \texttt{obj1} is added to represent the effect of the statement in
			line~\ref{line:ea:basics:ll:headassign} in~\cref{lst:ea:basics:ll}, completing intraprocedural analysis.

		\subsection{Interprocedural Analysis}
			\label{sub:ea:basics:global}
			Looking at the summary information generated for both methods given in~\cref{lst:ea:basics:ll}, the object node
			that represents the only allocation (\texttt{LinkedList} in~\cref{subfig:ea:basics:ll:addElement}) has an escape
			state of \emph{local} at this point in the analysis. Recall that local nodes are considered for stack allocation,
			but entries of a linked list cannot be allocated on stack. The results are thus not sound and further analysis is
			required. Looking at the example, the edge from \texttt{head} to \texttt{obj1} in the \gls{cg} of \texttt{insert}
			is the edge that will prevent stack allocation of the list element in \texttt{addElement}. To determine this
			algorithmically, the edges found while processing \texttt{insert} need to be propagated to its caller
			\texttt{addElement}. Once the connection from \texttt{obj0} via a new field reference node \texttt{head} to the
			list element is established, the escape state of the \texttt{ListElement} object node increase to \emph{method},
			making the result sound.

			A second analysis pass propagates information from the non-\emph{local} subgraph of the \glspl{cg} into the
			\glspl{cg} of all calling methods. This \emph{interprocedural} analysis modifies the summary information of the
			callers, which in turn require their callers to be updated again. To prevent unnecessary recalculation of
			information, this pass should use a bottom-up traversal of the call graph. In the absence of recursion, the call
			graph will not contain cycles, making this a simple problem. When recursion is used, identifying strongly
			connected components and iterating in each component until a fixpoint is reached has proved to be effective.
			KESO's implementation uses Tarjan's algorithm to identify strongly connected components in the call
			graph~\cite{tarjan:72:lga}.

			To update the callers' \acrlongpl{cg}, pairs of corresponding nodes in the graph on the caller and the callee side
			are identified as starting points and added to a work list. Originating at these anchors, further nodes and their
			counterparts are found and again added to the work list. While the work list isn't empty, processing continues and
			builds a relation of object nodes in the callee and the caller \gls{cg} called \emph{mapsToObj}. This step is
			called \emph{updateNodes}. A simplified form of the procedure is given in~\cref{algo:ea:basics:updateNodes}. It
			uses a dual work list approach to avoid creating spurious phantom nodes because some of the relationships might
			not be known until the algorithm completes. See~\cite[Sec.~3.2.1]{lang:12} for a detailed explanation of the
			problem that causes unneeded phantom nodes to be added and slows down the analysis. \emph{UpdateNodes} ensures
			that all object nodes used in a callee are represented in its caller. It also adds field reference nodes present
			in the callee \gls{cg} but missing from the caller's graph and marks the counterparts of globally escaping nodes
			in the callee's \gls{cg} as globally escaping in the caller \gls{cg}.

			\begin{algorithm}
				\SetKwData{workList}{workList}
				\SetKwData{needsPointee}{needsPointee}
				\SetKwData{mapsToObj}{mapsToObj}
				\SetKwData{mParam}{mParam}
				\SetKwData{iArg}{iArg}
				\SetKwData{x}{x}
				\SetKwData{y}{y}
				\SetKwData{xs}{xs}
				\SetKwData{ys}{ys}
				\SetKwData{xd}{xd}
				\SetKwData{yd}{yd}
				\SetKwData{xPointees}{xPointees}
				\SetKwData{yPointees}{yPointees}
				\SetKwData{calleeField}{calleeField}
				\SetKwData{callerField}{callerField}
				\SetKwData{callerObjs}{callerObjs}
				\SetKwFunction{updateNodes}{updateNodes}
				\SetKwFunction{updateEscapeState}{updateEscapeState}
				\SetKwFunction{pop}{pop}
				\SetKwFunction{pointees}{pointees}
				\SetKwFunction{fields}{fields}
				\SetKwFunction{getField}{getField}
				\SetKwFunction{addEdges}{addEdges}
				\SetKwFunction{createPhantom}{createPhantom}
				\SetKw{continue}{continue}

				\SetKwInOut{Input}{Input}
				\SetKwInOut{Output}{Result}
				\Input{\xs: method parameters, \ys: invocation arguments}
				\Output{\mapsToObj relation between caller and callee nodes}
				\BlankLine
				\DontPrintSemicolon
				\updateNodes$\left( \xs, \ys \right)$\;
				\PrintSemicolon
				\Begin{%
					\workList $= \left\{ (\x, \y) \left|\; \x \leftarrow \xs \left|\; \y \leftarrow \ys \right.\right.\right\}$\;
					\needsPointee $= \emptyset$\;
					\mapsToObj $= \emptyset$\;
					\While{$\workList \ne \emptyset \;\mathrm{or}\; \needsPointee \ne \emptyset$}{%
						\While{$\workList \ne \emptyset$}{%
							$\left(\mParam, \iArg\right) = \pop{\workList}$\;
							\BlankLine
							\tcp{Mark \mParam globally escaping if \iArg is.}
							$\updateEscapeState{\mParam, \iArg}$\;
							\BlankLine
							\tcp{Find pairs of descendant object nodes}
							$\xPointees = \pointees{\mParam}$\;
							$\yPointees = \pointees{\iArg}$\;
							\eIf{$\xPointees \equiv \emptyset \;\mathrm{or}\; \yPointees \ne \emptyset$}{%
								\tcp{Find pairs of field reference nodes}
								\ForEach{$\left( \xd, \yd \right) \in \left\{ (\x, \y) \left|\; \x \leftarrow \xPointees,\; \y \leftarrow \yPointees \right.\right\}$}{%
									$\mapsToObj{\xd} \;\cup\!\!= \yd$\;
									\ForEach{$\calleeField \in \fields{\xd}$}{%
										$\callerField = \getField{\yd, \calleeField}$\;
										$\workList \;\cup\!\!= (\calleeField, \callerField)$\;
									}
								}
							}{%
								\tcp{The callee node is not represented in the caller node}
								$\needsPointee \;\cup\!\!= (\mParam, \iArg)$\;
							}
						}
						\While{$\workList \equiv \emptyset \;\mathrm{and}\; \needsPointee \ne \emptyset$}{%
							\ForEach{$(\mParam, \iArg) \in \needsPointee$}{%
								\eIf{$\pointees{\iArg} \ne \emptyset$}{%
									\tcp{\mParam's pointees are represented (happens with recursion)}
								}{%
									\tcp{Check for other representatives of pointees of \mParam}
									$\callerObjs = \left\{ \x \left|\; \x \leftarrow \mapsToObj{\y} \left|\; \y \leftarrow \pointees{\mParam} \right.\right.\right\}$\;
									\eIf{$\callerObjs \ne \emptyset$}{%
										\addEdges{\iArg, \callerObjs}\;
									}{%
										\tcp{Delay adding phantom nodes}
										\continue\;
									}
								}
								$\needsPointee \;\setminus\!\!= (\mParam, \iArg)$\;
								$\workList \;\cup\!\!= (\mParam, \iArg)$\;
							}
							\If{$\workList \equiv \emptyset$}{%
								\tcp{\workList is still empty, no pairs found. Add a phantom node.}
								$(\mParam, \iArg) = \pop{\needsPointee}$\;
								$\addEdges{\iArg, \createPhantom{\mParam}}$\;
								$\workList \;\cup\!\!= (\mParam, \iArg)$\;
							}
						}
					}
				}

				\caption[The \emph{updateNodes} procedure]{The \emph{updateNodes} procedure~\cite[Alg. 2]{lang:12}}
				\label{algo:ea:basics:updateNodes}
			\end{algorithm}

			For the example given in~\cref{lst:ea:basics:ll} and~\cref{subfig:ea:basics:ll:addElement}, this means that the
			field reference nodes \texttt{head} and \texttt{next} are added below \texttt{obj0} and \texttt{ListElement}
			respectively. Furthermore, a phantom node is added to represent \texttt{oldhead}. Note that the \texttt{head}
			reference node does not yet point to the list element object node. The next step of the algorithm called
			\emph{updateEdges} adds the missing connection. It takes the same parameters as \emph{updateNodes}
			from~\cref{algo:ea:basics:updateNodes} and adds all missing edges. See~\cref{algo:ea:basics:updateEdges} for
			a pseudocode listing of the procedure. It identifies pairs of corresponding object nodes using the
			\emph{mapsToObj} relation computed in \emph{updateNodes}. For each possible pair it follows outgoing edges to any
			field reference nodes in the callee graph and finds the corresponding field reference node in the caller's
			\gls{cg}. Next, the newly found correspondence pair is added to the work list and all outgoing edges to object
			nodes in the callee graph are added to the caller graph. Note that code to prevent endless loops in cylic data
			structures has been left out for simplicity, but can be easily added.

			\begin{algorithm}
				\SetKwData{workList}{workList}
				\SetKwData{mParam}{mParam}
				\SetKwData{pairs}{pairs}
				\SetKwData{x}{x}
				\SetKwData{y}{y}
				\SetKwData{xs}{xs}
				\SetKwData{ys}{ys}
				\SetKwData{i}{i}
				\SetKwData{j}{j}
				\SetKwData{k}{k}
				\SetKwData{mapsToObj}{mapsToObj}
				\SetKwData{field}{field}
				\SetKwFunction{fields}{fields}
				\SetKwFunction{updateEdges}{updateEdges}
				\SetKwFunction{pop}{pop}
				\SetKwFunction{pointees}{pointees}
				\SetKwFunction{getField}{getField}
				\SetKwFunction{addEdges}{addEdges}

				\SetKwInOut{Input}{Input}
				\SetKwInOut{Output}{Result}
				\Input{\xs: method parameters, \ys: invocation arguments}
				\BlankLine
				\DontPrintSemicolon
				\updateEdges$\left( \xs, \ys \right)$\;
				\PrintSemicolon
				\Begin{%
					$\workList = \xs$\;
					\While{$\workList \ne \emptyset$}{%
						$\mParam = \pop{\workList}$\;
						\ForEach{$(\x, \y) \in \left\{ (\x, \y) \left|\; \y \leftarrow \mapsToObj{\x} \left|\; \x \leftarrow \pointees{\mParam} \right.\right.\right\}$}{%
							\ForEach{$(\i, \j) \in \left\{ (\field, \getField{\y, \field}) \left|\; \field \leftarrow \fields{\x} \right.\right\}$}{%
								$\workList \;\cup\!\!= (\i, \j)$\;
								\addEdges{$\j, \left\{ \mapsToObj{\k} \left|\; \k \leftarrow \pointees{\i} \right.\right\}$}\;
							}
						}
					}
				}

				\caption[The \emph{updateEdges} procedure]{The \emph{updateEdges} procedure~\cite[Alg. 3]{lang:12}}
				\label{algo:ea:basics:updateEdges}
			\end{algorithm}

			After interprocedural analysis, nodes marked \emph{local} in the \gls{cg} can be allocated on the stack. Note that
			KESO does not convert all allocations that fulfill this criterion into stack allocations. Instead, variable
			liveness information is used to compute whether multiple objects allocated at the same allocation site are needed
			at the same time. Objects with overlapping liveness regions are not allocated on the stack because the amount of
			memory used by these allocations might be unbounded, e.g.\ if the allocation is inside a loop.
			See~\cite[Sec.~3.3]{lang:12} for detailed rationale and a description of the implementation.

	\section{Improvements}
		\label{sec:ea:improve}
		The algorithm implemented in~\cite{lang:12}, which is based on~\cite{choi:03:toplas}, was improved for this thesis
		in a number of ways. Among these improvements was flow-sensitivity, which was proposed by Choi et al.\ in 2003, but
		not implemented in my bachelor's thesis. The changes required to achieve flow-sensitivity are outlined in the
		following~\cref{subsec:ea:improve:fs}. Furthermore, a problem producing possibly incorrect
		results was discovered in the algorithm given in~\cite{choi:03:toplas}. \Cref{subsec:ea:improve:bug} gives an
		example and explains where the incorrect analysis results occur and how they were fixed in KESO's implementation.

		Last but not least, the algorithm's runtime on large examples amounted to several minutes and was deemed
		unsatisfactory. Especially recursive and virtual method invocations significantly increased the size of the
		generated \glspl{cg}, raising the runtime of interprocedural analysis. \Cref{subsec:ea:improve:opt} deals with
		modifications implemented to reduce the runtime of the alias analysis.

		\subsection{Flow-Sensitivity}
			\label{subsec:ea:improve:fs}
			For flow-sensitive alias analysis a standard forward data flow analysis~\cite[Sec.~9.2]{aho:07:compilers} is used.
			The set of operations needed for data flow analysis is
			\begin{align}
				C_o^b &= f_b\left( C_i^b \right)\label{eq:ea:improve:fs:transfer}\\
				C_i^b &= \bigwedge_{x \;\in\; \operatorname{pred}(b)} C_o^x\label{eq:ea:improve:fs:meet}
			\end{align}
			where $C_i^b$ and $C_o^b$ are input and output data flow information for the basic block $b$, $f_b$
			in~\cref{eq:ea:improve:fs:transfer} is called the \emph{transfer function} for the basic block $b$, and $\wedge_{x
			\;\in\; \operatorname{pred}(b)}$ in~\cref{eq:ea:improve:fs:meet} is the \emph{meet} operation. The data flow
			transfer function modifies the data flow information (i.e., the \acrlong{cg}) according to the statements in the
			basic block $b$. The meet operation combines the output information of all predecessors of a basic block into the
			input information of a given basic block $b$. The basics of the transfer function are explained in~\cite{lang:12,
			choi:03:toplas}. In theory, all $C^b$ are distinct. In practice, this would manifold the memory requirements for
			the \glspl{cg}. Instead of copying the graph in each invocation of the transfer and meet operations, KESO's
			implementation uses a single representation. This idea is also present in~\cite[Sec.~3]{choi:03:toplas}, but is
			not explained very well. In specific, it is not clear to the author of this thesis what Choi et al.\ meant when
			they wrote \enquote{in the flow-sensitive version, we only kill local variables}~\cite[p.~885]{choi:03:toplas}.

			The KESO compiler achieves flow-sensitivity while retaining a single representation of the \gls{cg} by tagging all
			reference nodes with the basic block for which they are valid. Object nodes are not modified for flow-sensitive
			analysis. For each reference node used in at least one predecessor, the meet operation creates a representation of
			the reference in the current basic block and subsumes all outgoing edges present in the predecessors. For each
			assignment operation encountered by the transfer function, \emph{ByPass(p)} is called on the reference to be
			written. \emph{ByPass(p)} (as explained in~\cite{choi:03:toplas}) redirects all incoming deferred edges of $p$ to
			its successors and removes any outgoing edges (i.e., it ensures that strong updates are performed).

			After implementing this improvement, a fixpoint iteration used to reduce the number of unnecessary phantom nodes
			in intraprocedural analysis did no longer terminate for some inputs. This happened because the iteration tracked
			changes to the \gls{cg} rather than comparing the graph against an older copy. Due to the use of \emph{ByPass(p)},
			the graph was modified in every loop, but further processing returned to the previous state again. Switching to
			a comparison against an old copy of the \gls{cg} rather than tracking of modifications fixed this particular
			problem. To efficiently implement comparisons against older versions of the same graph, the \acrlong{cg}'s nodes
			were extended with the ability to store a copy of a single older state of outgoing edges.

		\subsection{Fixing Incorrect Results: The Double Return Bug}
			\label{subsec:ea:improve:bug}
			KESO's implementation of escape analysis produced incorrect results given inputs similar to those generated by the
			idea outlined in~\cref{sec:eea:idea}. Further analysis suggests this is a conceptual flaw in the work of Choi et
			al. See~\cref{lst:ea:improve:bug} for an example triggering this bug. The \texttt{getObject} method allocates two
			objects, passes them to \texttt{chooseOne}, which selects one of the two arguments at random and returns it. The
			return value of \texttt{chooseOne} is returned from \texttt{getObject}. Because either of the two objects
			allocated in \texttt{getObject} might escape, both allocations must not use stack memory.

			\inputthesiscode{java}{lst:ea:improve:bug}{Example exposing the double return flaw}{%
				A simplified example exposing the double return bug in KESO's escape analysis. One of the objects allocated in
				\texttt{getObject} is returned from its allocating method, but escape analysis did not detect this due to the
				use of phantom nodes to represent return values.
			}{examples/ChooseOne.java}

			However, the \gls{cg} constructed according to~\cite[Sec.~4]{choi:03:toplas} does not correctly identify the two
			objects as method-escaping. The \acrlong{cg} for \texttt{chooseOne} is straightforward and given
			in~\cref{subfig:ea:improve:bug:chooseOne}.

			\begin{figure}
				\centering%
				\subcaptionbox{%
					The \gls{cg} for \texttt{chooseOne}.%
					\label{subfig:ea:improve:bug:chooseOne}}[.4\textwidth]{%
						\centering%
						\input{examples/ChooseOne-chooseOne.tex}%
				}%
				\hspace{\fill}%
				\subcaptionbox{%
					The \gls{cg} for \texttt{getObject} according to~\cite[Sec.~4]{choi:03:toplas}.%
					\label{subfig:ea:improve:bug:getObject}}[.58\textwidth]{%
						\centering%
						\input{examples/ChooseOne-getObject.tex}%
				}%
				\caption[The \glspl{cg} for \texttt{getObject} and \texttt{chooseOne} exhibiting the double return flaw]{%
					The \glspl{cg} for \texttt{getObject} and \texttt{chooseOne} from~\cref{lst:ea:improve:bug}, exhibiting the
					double return flaw. The object nodes in \texttt{getObject} should be pointed-to by \texttt{ret}, which would
					raise their escape state to \emph{method}, but these edges are missing. Colors and shapes
					c.f.~\cref{fig:ea:basics:ll}.}%
				\label{fig:ea:improve:bug}%
			\end{figure}

			\todonote{Show that \texttt{Object chooseOne(Object a, Object b)} is not correctly handled by Choi's algorithm if
			the return value of this function is itself returned again. Show what I have done to improve that.}

		\subsection{Interprocedural Analysis Optimizations}
			\label{subsec:ea:improve:opt}
			\todonote{The work I did in my bachelor's thesis did take rather long especially on large examples. I have
			implemented a few optimizations to make it run faster. These are:}

			\subsubsection{No Propagation of Read Operations}
				\label{subsub:ea:improve:opt:writeonly}
				\todonote{Ignore read operations and propagate only writes. Explain how that has the potential of cutting down
				lots of nodes generated by vcalls to \texttt{equals(Object other)} (and why that does not work in the
				implementation we use).}

			\subsubsection{No Reprocessing of Unchanged Invocations}
				\label{subsub:ea:improve:opt:quick-fixpoint}
				\todonote{When iterating to find a fixpoint in a strongly connected component, only re-compute the summary
				information for a method if its callees actually changed; re-use the old results otherwise.}

			\subsubsection{Connection Graph Compression}
				\label{subsub:ea:improve:opt:compression}
				\todonote{Compress multiple sibling nodes if they likely represent the same node. This gives us a huge speedup
				without giving up too much information (explain how I made sure the relevant information is kept).}
