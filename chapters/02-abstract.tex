% vim:noet:sts=2:ts=2:sw=2:smarttab:tw=120

\cleardoublepage{}

\vspace*{\fill}

\begin{english}[variant = american]
	\begin{abstract}
		Escape analysis can be used for automatic memory management in Java. Based on the work of Choi et al.\ in
		2003~\cite{choi:03:toplas}, this thesis improves the existing escape analysis in KESO, a Java virtual machine for
		deeply embedded systems. Enhancements implemented for this document include flow-sensitive analysis, modifications
		that reduce compile time and a fix for a conceptual flaw in the work of Choi et al\@. Further analysis explored the
		possibility of allocating objects in callers' stack frames or memory regions.

		Based on the computed analysis results, two different optimization backends are presented and compared: The
		preexisting stack allocation and a new method using task-local heaps automatically managed in a stack-like fashion
		with precise overflow checks. Both methods have predictable allocation and deallocation behavior and can guarantee
		tight upper bounds on their runtime since they do not suffer from external fragmentation. This increases
		predictability, which is beneficial in an embedded real-time Java environment.

		Besides memory management, the thesis discusses other usage possibilities of the escape analysis results, such as
		optimizations in remote procedure calls, synchronization optimizations, and a new theoretical approach to
		cycle-aware reference counting.

		Compiler-assisted memory management pays positively: In a real-time Java benchmark, object lifetime is automatically
		inferred at up to 43.7~\% of all allocation sites. The optimizations reduce heap memory usage, in some cases to less
		than half of what it was without automatic memory management using escape analysis. Additionally, the benchmark's
		time requirements are cut short by up to 18.7~\%.
	\end{abstract}
\end{english}

\vspace*{\fill}
\cleardoublepage{}
\vspace*{\fill}

\begin{german}
	\begin{abstract}
		Fluchtanalyse kann in Java zur automatischen Speicherverwaltung genutzt werden. Basierend auf einer Arbeit von Choi
		et al.\ aus dem Jahr 2003~\cite{choi:03:toplas} verbessert diese Masterarbeit die existierende Fluchtanalyse in
		KESO, einer virtuellen Maschine für Java im Anwendungsfeld eingebetteter Systeme. Die Erweiterungen, die für dieses
		Dokument implementiert wurden, beinhalten Flusssensitivität, Modifikationen zur Reduzierung der Übersetzungszeit und
		die Korrektur eines inhaltlichen Fehlers in der Arbeit von Choi et al\@. Weitere Analysen untersuchten die
		Möglichkeit der Objektallokation in Stapelrahmen bzw.\ Speicherbereichen von Aufrufern.

		Basierend auf den berechneten Analyseergebnissen werden zwei Optimierungsmöglichkeiten vorgestellt und verglichen:
		Die bereits existierende Stapelallokation und eine neue Methode, die stapelähnlich verwaltete
		aktivitätsträger-lokale Halden mit präzisen Überlaufprüfungen benutzt. Beide Methoden besitzen vorhersagbares
		Allokations- und Deallokationsverhalten und können enge obere Schranken ihrer Laufzeit garantieren, weil sie nicht
		von externer Fragmentierung betroffen sind. Dies erhöht die Vorhersagbarkeit, was in eingebettetem Echtzeit-Java von
		Vorteil ist.

		Neben Speicherverwaltung beleuchtet diese Arbeit auch andere Nutzungsmöglichkeiten von Ergebnissen der
		Fluchtanalyse, wie Optimierungen in Fernaufrufen, Synchronisationsoptimierungen und einen neuen theoretischen Ansatz
		zur zyklengewahren Referenzzählung.

		Übersetzerunterstützte automatische Speicherverwaltung lohnt sich: In einem Leistungsbewertungsprogramm für
		Echtzeit-Java konnten die Lebensdauern der erzeugten Objekte an bis zu 43.7~\% aller Allokationsstellen automatisch
		bestimmt werden. Die Optimierungen reduzierten die Auslastung des Haldenspeichers im Vergleich zu Messungen ohne
		Speicherverwaltungstechniken, die auf Fluchtanalyse basieren, in einigen Fällen auf weniger als die Hälfte.
		Zusätzlich verbesserten sich die Ausführungszeiten des Leistungstests um bis zu~18.7~\%.
	\end{abstract}
\end{german}

\vspace*{\fill}
